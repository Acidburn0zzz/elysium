/*
 * generated by Xtext 2.10.0
 */
package org.elysium.formatting2

import com.google.inject.Inject
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.elysium.lilypond.Assignment
import org.elysium.lilypond.Expression
import org.elysium.lilypond.LilyPond
import org.elysium.services.LilyPondGrammarAccess

//TODO adapt from original LilyPondFormatter
//use Xtext example DomainmodelFormatter/RuleEngineFormatter for inspiration
class LilyPondFormatter extends AbstractFormatter2 {

	public static final String[][] BLOCK_KEYWORD_PAIRS = #[#["%{", "%}"], //$NON-NLS-1$ //$NON-NLS-2$ 
		#[ "{", "}" ], //$NON-NLS-1$ //$NON-NLS-2$
		#[ "<<", ">>" ]]; //$NON-NLS-1$ //$NON-NLS-2$

	@Inject extension LilyPondGrammarAccess

	def dispatch void format(LilyPond lilyPond, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Expression expressions : lilyPond.getExpressions()) {
			expressions.format;
		}
	}

	def dispatch void format(Assignment assignment, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		assignment.getValue.format;
	}
	
	// TODO: implement for SimpleBlock, SimultaneousBlock, UnparsedBlock, Include, Markup, MarkupLines, MarkupList, MarkupBody, BlockCommand, OutputDefinition, RelativeMusic, Pitch, TransposedMusic, ModeChange, MusicWithLyrics, NewContext, ContextModification, ContextDef, Scheme, SchemeExpression, SchemeList, SchemeBlock
}


//original formatter configuration code
/*
 	@Override
	protected void configureFormatting(FormattingConfig config) {
		LilyPondGrammarAccess grammar = (LilyPondGrammarAccess)getGrammarAccess();
		// No space
		List<Keyword> noSpaceAfter = grammar.findKeywords(LilyPondConstants.BACKSLASH, "#"); //$NON-NLS-1$
		for (Keyword keyword : noSpaceAfter) {
			config.setNoSpace().after(keyword);
		}
		List<Keyword> noSpaceBefore = grammar.findKeywords("'", ",", "(", ")"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
		for (Keyword keyword : noSpaceBefore) {
			config.setNoSpace().before(keyword);
		}
		config.setNoSpace().before(grammar.getNumberRule());
		config.setNoSpace().before(grammar.getANY_OTHERRule()); // FIXME doesn't seem to apply
		// Line wrap
		config.setLinewrap().after(grammar.getIncludeRule());
		config.setLinewrap(2).after(grammar.getVersionRule());
		config.setLinewrap(2).after(grammar.getAssignmentRule());
//		config.setLinewrap().after(grammar.getPropertyAssignmentRule());
		// Blocks
		for (String[] blockKeywordPair : BLOCK_KEYWORD_PAIRS) {
			for (Pair<Keyword, Keyword> pair : grammar.findKeywordPairs(blockKeywordPair[0], blockKeywordPair[1])) {
				Keyword first = pair.getFirst();
				Keyword second = pair.getSecond();
				config.setIndentation(first, second);
				config.setLinewrap().after(first);
				config.setLinewrap().before(second);
				config.setLinewrap().after(second);
			}
		}
		// Comments
		config.setLinewrap(0, 1, 2).before(grammar.getSL_COMMENTRule());
		config.setLinewrap(0, 1, 2).before(grammar.getML_COMMENTRule());
		config.setLinewrap(0, 1, 1).after(grammar.getML_COMMENTRule());
		config.setLinewrap(0, 1, 2).before(grammar.getSCHEME_ML_COMMENTRule());
		config.setLinewrap(0, 1, 1).after(grammar.getSCHEME_ML_COMMENTRule());
	}
 
 
 */