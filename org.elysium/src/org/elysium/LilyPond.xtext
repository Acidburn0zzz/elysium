/**
 * there are a few integration tests still failing with the following errors
 * 
 * 1) cannot find variable RH because it is not defined as an assignment but rather via
 *    #(define RH...)
 * 
 * 2) cannot find variable slashSeparator; which is defined in titling-init.ly
 * but that file is neither included explicitly and nor a default import
 * */
grammar org.elysium.LilyPond hidden(WS, SL_COMMENT, ML_COMMENT, NL_NOINDENT)

generate lilypond "http://www.elysium.org/LilyPond"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

LilyPond: expressions+=Expression*;

Expression: Assignment | CommonExpression;

CommonExpression: Command | Block | Scheme | Number | Text;

Assignment: name=(ID | STRING) "=" value=Expression;

PropertyAssignment: id=SchemeIdentifier "=" value=Expression;

Block: SimpleBlock | SimultaneousBlock;

SimpleBlock: {SimpleBlock} "{" expressions+=Expression* "}";

SimultaneousBlock: {SimultaneousBlock} "<<" expressions+=Expression* ">>";

Command: SpecialCommand | Reference | StringIndication;

SpecialCharacter: "!" | "?" | "+" | "<" | ">" | "[" | "]" | "~";

UnparsedBlock: {UnparsedBlock} "{" expressions+=UnparsedExpression* "}";

UnparsedExpression: BlockCommand | PropertyAssignment | UnparsedCommand | UnparsedBlock | Scheme | Number | Text;

UnparsedCommand: "\\" command=(SchemeIdentifier | SpecialCommandName);

Reference: "\\" assignment=[Assignment];

Text: value=(SchemeTextValueSegment | "(" | ")" | "'" | "," | ":");

Number: value=INT;

// Commands

SpecialCommand: Include | Version | SourceFileName | SourceFileLine | Markup | MarkupLines | BlockCommand | OutputDefinition | RelativeMusic | TransposedMusic | ModeChange | MusicWithLyrics | NewContext | ContextDef | Other;

Include: "\\" keyword="include" importURI=STRING;

Version: "\\" keyword="version" version=STRING;

SourceFileName: "\\" keyword="sourcefilename" filename=STRING;

SourceFileLine: "\\" keyword="sourcefileline" line=INT;

Markup: "\\" keyword="markup" body=MarkupBody; // XXX very messy 

MarkupLines: "\\" keyword="markuplines" body=MarkupBody;

//I split up Scheme/SchemeText, using special definitions for the MarkupBody-Command-case
//so that I can enforce different hidden-Definitions
//that way I can prevent the eating up of assignments that start on a new line without indentation
MarkupBody: {MarkupBody} command+=(MarkupCommandScheme | MarkupCommandSchemeText | UnparsedCommand)* block=UnparsedBlock?; // XXX SchemeText? see tocItemWithDotsMarkup

BlockCommand: "\\" keyword=("book" | "bookpart" | "header" | "score") block=SimpleBlock;

OutputDefinition: "\\" keyword=("paper" | "midi" | "layout") block=UnparsedBlock;

RelativeMusic: "\\" keyword="relative" pitch=Pitch? music=Expression;

Pitch: base=ID octaveCheck?="="? octaveShift=Octave? reminderAccidental?="!"? cautionaryAccidental?="?"?;

Octave: up+="'"+ | down+=","+;

TransposedMusic: "\\" keyword="transpose" source=Pitch target=Pitch music=Expression;
 
ModeChange: "\\" keyword=("chordmode" | "drummode" | "figuremode" | "lyricmode" | "notemode") music=Block;

MusicWithLyrics: "\\" keyword="lyricsto" id=(ID | STRING) lyrics=Expression;

NewContext: "\\" keyword=("new" | "context") context=ID ("=" id=(ID | STRING))? modification=ContextModification? music=Expression;

ContextModification: "\\" "with" block=UnparsedBlock;

ContextDef: "\\" keyword="context" block=UnparsedBlock;

StringIndication: "\\" string=INT;

Other: "\\" keyword=(SpecialCharacter | "(" | ")" | OtherName);

OtherName: "accepts" | "addlyrics" | "alias" | "alternative" | "change" | "chords" | "consists" | "default" | "defaultchild" | "denies" | "description" | "drums" | "figures" | "grobdescriptions" | "key" | "lyrics" | "maininput" | "mark" | "name" | "objectid" | "octave" | "once" | "override" | "partial" | "remove" | "repeat" | "rest" | "revert" | "sequential" | "set" | "simultaneous" | "skip" | "tempo" | "time" | "times" | "type" | "unset" | "with";

SpecialCommandName: "include" | "version" | "sourcefilename" | "sourcefileline" | "markup" | "markuplines" | "book" | "bookpart" | "context" | "header" | "score" | "paper" | "midi" | "layout" | "relative" | "transpose" | "chordmode" | "drummode" | "figuremode" | "lyricmode" | "notemode" | "lyricsto" | "new" | "with" | OtherName; // XXX this must duplicate all known commands 

// Scheme

Scheme hidden(WS, SL_COMMENT, ML_COMMENT, SCHEME_SL_COMMENT, SCHEME_ML_COMMENT, NL_NOINDENT): ("#" | "$") value=SchemeExpression;
MarkupCommandScheme returns Scheme hidden(WS, SL_COMMENT, ML_COMMENT, SCHEME_SL_COMMENT, SCHEME_ML_COMMENT): ("#" | "$") value=SchemeExpression;

SchemeExpression: quotations+=("'" | "`" | "," | "@")* reference?="$"? value=SchemeValue;

SchemeValue: SchemeBoolean | SchemeList | SchemeBlock | SchemeCharacter | SchemeNumber | SchemeText | SchemeMarkupCommand;

SchemeBoolean: value=SchemeBooleanValue;

SchemeBooleanValue returns ecore::EBoolean: "#" ID;

SchemeList: {SchemeList} vector?="#"? "(" expressions+=SchemeExpression* ")";

SchemeBlock: "#{" elements+=Expression+ "#}";

//added "-" to List, there were tests failing because of that
SchemeCharacter: "#\\" value=(ID | SpecialCharacter | '-' | ANY_OTHER);

SchemeText: value=SchemeTextValue;
MarkupCommandSchemeText returns SchemeText hidden(WS, SL_COMMENT, ML_COMMENT): value=SchemeTextValue;

SchemeTextValue: SchemeTextValueSegment (":" ":"? SchemeTextValueSegment)*;

SchemeTextValueSegment: "\\\\" | "=" | "-" | SpecialCharacter | SchemeIdentifier | STRING | INT | ANY_OTHER;

SchemeIdentifier: Identifier ("-" Identifier)*;

Identifier: ID | SpecialCommandName;

SchemeNumber: radix=SchemeNumberRadix? value=SignedInteger;

SchemeNumberRadix: "#" ID;

SignedInteger: "-"? INT;

SchemeMarkupCommand: "#:" command=SchemeIdentifier;

// Terminals

//why was the STRING definition so restrictive wrt. escaping?
//if it's essential, semantic validation is a better alternative
//terminal STRING: '"' ("\\" ("a".."z" | "A".."Z" | '"' | "'" | "\\") | !("\\" | '"'))* '"';
terminal STRING: '"' ("\\" . | !("\\" | '"'))* '"';

terminal INT returns ecore::EInt: ("0".."9")+;

terminal ID: ("a".."z" | "A".."Z" | "¡".."ￜ")+;

//for distinguishing new line with no indentation -> heuristic is we are not in a markup anymore
terminal NL_NOINDENT: (("\r" | "\n")*(" " | "\t" ))* ("\r" | "\n")+;

terminal WS: (" " | "\t" | "\r" | "\n")+;

terminal SL_COMMENT: "%" !("\n" | "\r")* ("\r"? "\n")?;

terminal ML_COMMENT: "%{" -> "%}";

terminal SCHEME_SL_COMMENT: ";;" !("\n" | "\r")* ("\r"? "\n")?;

terminal SCHEME_ML_COMMENT: "#!" -> "!#";

terminal ANY_OTHER: .;